
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `TokenUsageRecord` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model TokenUsageRecord
 * 
 */
export type TokenUsageRecordModel = runtime.Types.Result.DefaultSelection<Prisma.$TokenUsageRecordPayload>

export type AggregateTokenUsageRecord = {
  _count: TokenUsageRecordCountAggregateOutputType | null
  _avg: TokenUsageRecordAvgAggregateOutputType | null
  _sum: TokenUsageRecordSumAggregateOutputType | null
  _min: TokenUsageRecordMinAggregateOutputType | null
  _max: TokenUsageRecordMaxAggregateOutputType | null
}

export type TokenUsageRecordAvgAggregateOutputType = {
  promptTokens: number | null
  completionTokens: number | null
  totalTokens: number | null
  cachedTokens: number | null
  reasoningTokens: number | null
}

export type TokenUsageRecordSumAggregateOutputType = {
  promptTokens: number | null
  completionTokens: number | null
  totalTokens: number | null
  cachedTokens: number | null
  reasoningTokens: number | null
}

export type TokenUsageRecordMinAggregateOutputType = {
  id: string | null
  userId: string | null
  modelPricingId: string | null
  promptTokens: number | null
  completionTokens: number | null
  totalTokens: number | null
  cachedTokens: number | null
  reasoningTokens: number | null
  createdAt: Date | null
  updatedAt: Date | null
}

export type TokenUsageRecordMaxAggregateOutputType = {
  id: string | null
  userId: string | null
  modelPricingId: string | null
  promptTokens: number | null
  completionTokens: number | null
  totalTokens: number | null
  cachedTokens: number | null
  reasoningTokens: number | null
  createdAt: Date | null
  updatedAt: Date | null
}

export type TokenUsageRecordCountAggregateOutputType = {
  id: number
  userId: number
  modelPricingId: number
  promptTokens: number
  completionTokens: number
  totalTokens: number
  cachedTokens: number
  reasoningTokens: number
  createdAt: number
  updatedAt: number
  _all: number
}


export type TokenUsageRecordAvgAggregateInputType = {
  promptTokens?: true
  completionTokens?: true
  totalTokens?: true
  cachedTokens?: true
  reasoningTokens?: true
}

export type TokenUsageRecordSumAggregateInputType = {
  promptTokens?: true
  completionTokens?: true
  totalTokens?: true
  cachedTokens?: true
  reasoningTokens?: true
}

export type TokenUsageRecordMinAggregateInputType = {
  id?: true
  userId?: true
  modelPricingId?: true
  promptTokens?: true
  completionTokens?: true
  totalTokens?: true
  cachedTokens?: true
  reasoningTokens?: true
  createdAt?: true
  updatedAt?: true
}

export type TokenUsageRecordMaxAggregateInputType = {
  id?: true
  userId?: true
  modelPricingId?: true
  promptTokens?: true
  completionTokens?: true
  totalTokens?: true
  cachedTokens?: true
  reasoningTokens?: true
  createdAt?: true
  updatedAt?: true
}

export type TokenUsageRecordCountAggregateInputType = {
  id?: true
  userId?: true
  modelPricingId?: true
  promptTokens?: true
  completionTokens?: true
  totalTokens?: true
  cachedTokens?: true
  reasoningTokens?: true
  createdAt?: true
  updatedAt?: true
  _all?: true
}

export type TokenUsageRecordAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which TokenUsageRecord to aggregate.
   */
  where?: Prisma.TokenUsageRecordWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of TokenUsageRecords to fetch.
   */
  orderBy?: Prisma.TokenUsageRecordOrderByWithRelationInput | Prisma.TokenUsageRecordOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.TokenUsageRecordWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` TokenUsageRecords from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` TokenUsageRecords.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned TokenUsageRecords
  **/
  _count?: true | TokenUsageRecordCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to average
  **/
  _avg?: TokenUsageRecordAvgAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to sum
  **/
  _sum?: TokenUsageRecordSumAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: TokenUsageRecordMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: TokenUsageRecordMaxAggregateInputType
}

export type GetTokenUsageRecordAggregateType<T extends TokenUsageRecordAggregateArgs> = {
      [P in keyof T & keyof AggregateTokenUsageRecord]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateTokenUsageRecord[P]>
    : Prisma.GetScalarType<T[P], AggregateTokenUsageRecord[P]>
}




export type TokenUsageRecordGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.TokenUsageRecordWhereInput
  orderBy?: Prisma.TokenUsageRecordOrderByWithAggregationInput | Prisma.TokenUsageRecordOrderByWithAggregationInput[]
  by: Prisma.TokenUsageRecordScalarFieldEnum[] | Prisma.TokenUsageRecordScalarFieldEnum
  having?: Prisma.TokenUsageRecordScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: TokenUsageRecordCountAggregateInputType | true
  _avg?: TokenUsageRecordAvgAggregateInputType
  _sum?: TokenUsageRecordSumAggregateInputType
  _min?: TokenUsageRecordMinAggregateInputType
  _max?: TokenUsageRecordMaxAggregateInputType
}

export type TokenUsageRecordGroupByOutputType = {
  id: string
  userId: string
  modelPricingId: string
  promptTokens: number
  completionTokens: number
  totalTokens: number
  cachedTokens: number
  reasoningTokens: number
  createdAt: Date
  updatedAt: Date
  _count: TokenUsageRecordCountAggregateOutputType | null
  _avg: TokenUsageRecordAvgAggregateOutputType | null
  _sum: TokenUsageRecordSumAggregateOutputType | null
  _min: TokenUsageRecordMinAggregateOutputType | null
  _max: TokenUsageRecordMaxAggregateOutputType | null
}

type GetTokenUsageRecordGroupByPayload<T extends TokenUsageRecordGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<TokenUsageRecordGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof TokenUsageRecordGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], TokenUsageRecordGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], TokenUsageRecordGroupByOutputType[P]>
      }
    >
  >



export type TokenUsageRecordWhereInput = {
  AND?: Prisma.TokenUsageRecordWhereInput | Prisma.TokenUsageRecordWhereInput[]
  OR?: Prisma.TokenUsageRecordWhereInput[]
  NOT?: Prisma.TokenUsageRecordWhereInput | Prisma.TokenUsageRecordWhereInput[]
  id?: Prisma.StringFilter<"TokenUsageRecord"> | string
  userId?: Prisma.StringFilter<"TokenUsageRecord"> | string
  modelPricingId?: Prisma.StringFilter<"TokenUsageRecord"> | string
  promptTokens?: Prisma.IntFilter<"TokenUsageRecord"> | number
  completionTokens?: Prisma.IntFilter<"TokenUsageRecord"> | number
  totalTokens?: Prisma.IntFilter<"TokenUsageRecord"> | number
  cachedTokens?: Prisma.IntFilter<"TokenUsageRecord"> | number
  reasoningTokens?: Prisma.IntFilter<"TokenUsageRecord"> | number
  createdAt?: Prisma.DateTimeFilter<"TokenUsageRecord"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"TokenUsageRecord"> | Date | string
  user?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>
  modelPricing?: Prisma.XOR<Prisma.ModelPricingScalarRelationFilter, Prisma.ModelPricingWhereInput>
}

export type TokenUsageRecordOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  modelPricingId?: Prisma.SortOrder
  promptTokens?: Prisma.SortOrder
  completionTokens?: Prisma.SortOrder
  totalTokens?: Prisma.SortOrder
  cachedTokens?: Prisma.SortOrder
  reasoningTokens?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
  user?: Prisma.UserOrderByWithRelationInput
  modelPricing?: Prisma.ModelPricingOrderByWithRelationInput
}

export type TokenUsageRecordWhereUniqueInput = Prisma.AtLeast<{
  id?: string
  userId_modelPricingId?: Prisma.TokenUsageRecordUserIdModelPricingIdCompoundUniqueInput
  AND?: Prisma.TokenUsageRecordWhereInput | Prisma.TokenUsageRecordWhereInput[]
  OR?: Prisma.TokenUsageRecordWhereInput[]
  NOT?: Prisma.TokenUsageRecordWhereInput | Prisma.TokenUsageRecordWhereInput[]
  userId?: Prisma.StringFilter<"TokenUsageRecord"> | string
  modelPricingId?: Prisma.StringFilter<"TokenUsageRecord"> | string
  promptTokens?: Prisma.IntFilter<"TokenUsageRecord"> | number
  completionTokens?: Prisma.IntFilter<"TokenUsageRecord"> | number
  totalTokens?: Prisma.IntFilter<"TokenUsageRecord"> | number
  cachedTokens?: Prisma.IntFilter<"TokenUsageRecord"> | number
  reasoningTokens?: Prisma.IntFilter<"TokenUsageRecord"> | number
  createdAt?: Prisma.DateTimeFilter<"TokenUsageRecord"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"TokenUsageRecord"> | Date | string
  user?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>
  modelPricing?: Prisma.XOR<Prisma.ModelPricingScalarRelationFilter, Prisma.ModelPricingWhereInput>
}, "id" | "userId_modelPricingId">

export type TokenUsageRecordOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  modelPricingId?: Prisma.SortOrder
  promptTokens?: Prisma.SortOrder
  completionTokens?: Prisma.SortOrder
  totalTokens?: Prisma.SortOrder
  cachedTokens?: Prisma.SortOrder
  reasoningTokens?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
  _count?: Prisma.TokenUsageRecordCountOrderByAggregateInput
  _avg?: Prisma.TokenUsageRecordAvgOrderByAggregateInput
  _max?: Prisma.TokenUsageRecordMaxOrderByAggregateInput
  _min?: Prisma.TokenUsageRecordMinOrderByAggregateInput
  _sum?: Prisma.TokenUsageRecordSumOrderByAggregateInput
}

export type TokenUsageRecordScalarWhereWithAggregatesInput = {
  AND?: Prisma.TokenUsageRecordScalarWhereWithAggregatesInput | Prisma.TokenUsageRecordScalarWhereWithAggregatesInput[]
  OR?: Prisma.TokenUsageRecordScalarWhereWithAggregatesInput[]
  NOT?: Prisma.TokenUsageRecordScalarWhereWithAggregatesInput | Prisma.TokenUsageRecordScalarWhereWithAggregatesInput[]
  id?: Prisma.StringWithAggregatesFilter<"TokenUsageRecord"> | string
  userId?: Prisma.StringWithAggregatesFilter<"TokenUsageRecord"> | string
  modelPricingId?: Prisma.StringWithAggregatesFilter<"TokenUsageRecord"> | string
  promptTokens?: Prisma.IntWithAggregatesFilter<"TokenUsageRecord"> | number
  completionTokens?: Prisma.IntWithAggregatesFilter<"TokenUsageRecord"> | number
  totalTokens?: Prisma.IntWithAggregatesFilter<"TokenUsageRecord"> | number
  cachedTokens?: Prisma.IntWithAggregatesFilter<"TokenUsageRecord"> | number
  reasoningTokens?: Prisma.IntWithAggregatesFilter<"TokenUsageRecord"> | number
  createdAt?: Prisma.DateTimeWithAggregatesFilter<"TokenUsageRecord"> | Date | string
  updatedAt?: Prisma.DateTimeWithAggregatesFilter<"TokenUsageRecord"> | Date | string
}

export type TokenUsageRecordCreateInput = {
  id?: string
  promptTokens: number
  completionTokens: number
  totalTokens: number
  cachedTokens?: number
  reasoningTokens?: number
  createdAt?: Date | string
  updatedAt?: Date | string
  user: Prisma.UserCreateNestedOneWithoutTokenUsageRecordsInput
  modelPricing: Prisma.ModelPricingCreateNestedOneWithoutTokenUsageRecordsInput
}

export type TokenUsageRecordUncheckedCreateInput = {
  id?: string
  userId: string
  modelPricingId: string
  promptTokens: number
  completionTokens: number
  totalTokens: number
  cachedTokens?: number
  reasoningTokens?: number
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type TokenUsageRecordUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  promptTokens?: Prisma.IntFieldUpdateOperationsInput | number
  completionTokens?: Prisma.IntFieldUpdateOperationsInput | number
  totalTokens?: Prisma.IntFieldUpdateOperationsInput | number
  cachedTokens?: Prisma.IntFieldUpdateOperationsInput | number
  reasoningTokens?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  user?: Prisma.UserUpdateOneRequiredWithoutTokenUsageRecordsNestedInput
  modelPricing?: Prisma.ModelPricingUpdateOneRequiredWithoutTokenUsageRecordsNestedInput
}

export type TokenUsageRecordUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  modelPricingId?: Prisma.StringFieldUpdateOperationsInput | string
  promptTokens?: Prisma.IntFieldUpdateOperationsInput | number
  completionTokens?: Prisma.IntFieldUpdateOperationsInput | number
  totalTokens?: Prisma.IntFieldUpdateOperationsInput | number
  cachedTokens?: Prisma.IntFieldUpdateOperationsInput | number
  reasoningTokens?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type TokenUsageRecordCreateManyInput = {
  id?: string
  userId: string
  modelPricingId: string
  promptTokens: number
  completionTokens: number
  totalTokens: number
  cachedTokens?: number
  reasoningTokens?: number
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type TokenUsageRecordUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  promptTokens?: Prisma.IntFieldUpdateOperationsInput | number
  completionTokens?: Prisma.IntFieldUpdateOperationsInput | number
  totalTokens?: Prisma.IntFieldUpdateOperationsInput | number
  cachedTokens?: Prisma.IntFieldUpdateOperationsInput | number
  reasoningTokens?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type TokenUsageRecordUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  modelPricingId?: Prisma.StringFieldUpdateOperationsInput | string
  promptTokens?: Prisma.IntFieldUpdateOperationsInput | number
  completionTokens?: Prisma.IntFieldUpdateOperationsInput | number
  totalTokens?: Prisma.IntFieldUpdateOperationsInput | number
  cachedTokens?: Prisma.IntFieldUpdateOperationsInput | number
  reasoningTokens?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type TokenUsageRecordListRelationFilter = {
  every?: Prisma.TokenUsageRecordWhereInput
  some?: Prisma.TokenUsageRecordWhereInput
  none?: Prisma.TokenUsageRecordWhereInput
}

export type TokenUsageRecordOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type TokenUsageRecordUserIdModelPricingIdCompoundUniqueInput = {
  userId: string
  modelPricingId: string
}

export type TokenUsageRecordCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  modelPricingId?: Prisma.SortOrder
  promptTokens?: Prisma.SortOrder
  completionTokens?: Prisma.SortOrder
  totalTokens?: Prisma.SortOrder
  cachedTokens?: Prisma.SortOrder
  reasoningTokens?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type TokenUsageRecordAvgOrderByAggregateInput = {
  promptTokens?: Prisma.SortOrder
  completionTokens?: Prisma.SortOrder
  totalTokens?: Prisma.SortOrder
  cachedTokens?: Prisma.SortOrder
  reasoningTokens?: Prisma.SortOrder
}

export type TokenUsageRecordMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  modelPricingId?: Prisma.SortOrder
  promptTokens?: Prisma.SortOrder
  completionTokens?: Prisma.SortOrder
  totalTokens?: Prisma.SortOrder
  cachedTokens?: Prisma.SortOrder
  reasoningTokens?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type TokenUsageRecordMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  modelPricingId?: Prisma.SortOrder
  promptTokens?: Prisma.SortOrder
  completionTokens?: Prisma.SortOrder
  totalTokens?: Prisma.SortOrder
  cachedTokens?: Prisma.SortOrder
  reasoningTokens?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type TokenUsageRecordSumOrderByAggregateInput = {
  promptTokens?: Prisma.SortOrder
  completionTokens?: Prisma.SortOrder
  totalTokens?: Prisma.SortOrder
  cachedTokens?: Prisma.SortOrder
  reasoningTokens?: Prisma.SortOrder
}

export type TokenUsageRecordCreateNestedManyWithoutUserInput = {
  create?: Prisma.XOR<Prisma.TokenUsageRecordCreateWithoutUserInput, Prisma.TokenUsageRecordUncheckedCreateWithoutUserInput> | Prisma.TokenUsageRecordCreateWithoutUserInput[] | Prisma.TokenUsageRecordUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.TokenUsageRecordCreateOrConnectWithoutUserInput | Prisma.TokenUsageRecordCreateOrConnectWithoutUserInput[]
  createMany?: Prisma.TokenUsageRecordCreateManyUserInputEnvelope
  connect?: Prisma.TokenUsageRecordWhereUniqueInput | Prisma.TokenUsageRecordWhereUniqueInput[]
}

export type TokenUsageRecordUncheckedCreateNestedManyWithoutUserInput = {
  create?: Prisma.XOR<Prisma.TokenUsageRecordCreateWithoutUserInput, Prisma.TokenUsageRecordUncheckedCreateWithoutUserInput> | Prisma.TokenUsageRecordCreateWithoutUserInput[] | Prisma.TokenUsageRecordUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.TokenUsageRecordCreateOrConnectWithoutUserInput | Prisma.TokenUsageRecordCreateOrConnectWithoutUserInput[]
  createMany?: Prisma.TokenUsageRecordCreateManyUserInputEnvelope
  connect?: Prisma.TokenUsageRecordWhereUniqueInput | Prisma.TokenUsageRecordWhereUniqueInput[]
}

export type TokenUsageRecordUpdateManyWithoutUserNestedInput = {
  create?: Prisma.XOR<Prisma.TokenUsageRecordCreateWithoutUserInput, Prisma.TokenUsageRecordUncheckedCreateWithoutUserInput> | Prisma.TokenUsageRecordCreateWithoutUserInput[] | Prisma.TokenUsageRecordUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.TokenUsageRecordCreateOrConnectWithoutUserInput | Prisma.TokenUsageRecordCreateOrConnectWithoutUserInput[]
  upsert?: Prisma.TokenUsageRecordUpsertWithWhereUniqueWithoutUserInput | Prisma.TokenUsageRecordUpsertWithWhereUniqueWithoutUserInput[]
  createMany?: Prisma.TokenUsageRecordCreateManyUserInputEnvelope
  set?: Prisma.TokenUsageRecordWhereUniqueInput | Prisma.TokenUsageRecordWhereUniqueInput[]
  disconnect?: Prisma.TokenUsageRecordWhereUniqueInput | Prisma.TokenUsageRecordWhereUniqueInput[]
  delete?: Prisma.TokenUsageRecordWhereUniqueInput | Prisma.TokenUsageRecordWhereUniqueInput[]
  connect?: Prisma.TokenUsageRecordWhereUniqueInput | Prisma.TokenUsageRecordWhereUniqueInput[]
  update?: Prisma.TokenUsageRecordUpdateWithWhereUniqueWithoutUserInput | Prisma.TokenUsageRecordUpdateWithWhereUniqueWithoutUserInput[]
  updateMany?: Prisma.TokenUsageRecordUpdateManyWithWhereWithoutUserInput | Prisma.TokenUsageRecordUpdateManyWithWhereWithoutUserInput[]
  deleteMany?: Prisma.TokenUsageRecordScalarWhereInput | Prisma.TokenUsageRecordScalarWhereInput[]
}

export type TokenUsageRecordUncheckedUpdateManyWithoutUserNestedInput = {
  create?: Prisma.XOR<Prisma.TokenUsageRecordCreateWithoutUserInput, Prisma.TokenUsageRecordUncheckedCreateWithoutUserInput> | Prisma.TokenUsageRecordCreateWithoutUserInput[] | Prisma.TokenUsageRecordUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.TokenUsageRecordCreateOrConnectWithoutUserInput | Prisma.TokenUsageRecordCreateOrConnectWithoutUserInput[]
  upsert?: Prisma.TokenUsageRecordUpsertWithWhereUniqueWithoutUserInput | Prisma.TokenUsageRecordUpsertWithWhereUniqueWithoutUserInput[]
  createMany?: Prisma.TokenUsageRecordCreateManyUserInputEnvelope
  set?: Prisma.TokenUsageRecordWhereUniqueInput | Prisma.TokenUsageRecordWhereUniqueInput[]
  disconnect?: Prisma.TokenUsageRecordWhereUniqueInput | Prisma.TokenUsageRecordWhereUniqueInput[]
  delete?: Prisma.TokenUsageRecordWhereUniqueInput | Prisma.TokenUsageRecordWhereUniqueInput[]
  connect?: Prisma.TokenUsageRecordWhereUniqueInput | Prisma.TokenUsageRecordWhereUniqueInput[]
  update?: Prisma.TokenUsageRecordUpdateWithWhereUniqueWithoutUserInput | Prisma.TokenUsageRecordUpdateWithWhereUniqueWithoutUserInput[]
  updateMany?: Prisma.TokenUsageRecordUpdateManyWithWhereWithoutUserInput | Prisma.TokenUsageRecordUpdateManyWithWhereWithoutUserInput[]
  deleteMany?: Prisma.TokenUsageRecordScalarWhereInput | Prisma.TokenUsageRecordScalarWhereInput[]
}

export type TokenUsageRecordCreateNestedManyWithoutModelPricingInput = {
  create?: Prisma.XOR<Prisma.TokenUsageRecordCreateWithoutModelPricingInput, Prisma.TokenUsageRecordUncheckedCreateWithoutModelPricingInput> | Prisma.TokenUsageRecordCreateWithoutModelPricingInput[] | Prisma.TokenUsageRecordUncheckedCreateWithoutModelPricingInput[]
  connectOrCreate?: Prisma.TokenUsageRecordCreateOrConnectWithoutModelPricingInput | Prisma.TokenUsageRecordCreateOrConnectWithoutModelPricingInput[]
  createMany?: Prisma.TokenUsageRecordCreateManyModelPricingInputEnvelope
  connect?: Prisma.TokenUsageRecordWhereUniqueInput | Prisma.TokenUsageRecordWhereUniqueInput[]
}

export type TokenUsageRecordUncheckedCreateNestedManyWithoutModelPricingInput = {
  create?: Prisma.XOR<Prisma.TokenUsageRecordCreateWithoutModelPricingInput, Prisma.TokenUsageRecordUncheckedCreateWithoutModelPricingInput> | Prisma.TokenUsageRecordCreateWithoutModelPricingInput[] | Prisma.TokenUsageRecordUncheckedCreateWithoutModelPricingInput[]
  connectOrCreate?: Prisma.TokenUsageRecordCreateOrConnectWithoutModelPricingInput | Prisma.TokenUsageRecordCreateOrConnectWithoutModelPricingInput[]
  createMany?: Prisma.TokenUsageRecordCreateManyModelPricingInputEnvelope
  connect?: Prisma.TokenUsageRecordWhereUniqueInput | Prisma.TokenUsageRecordWhereUniqueInput[]
}

export type TokenUsageRecordUpdateManyWithoutModelPricingNestedInput = {
  create?: Prisma.XOR<Prisma.TokenUsageRecordCreateWithoutModelPricingInput, Prisma.TokenUsageRecordUncheckedCreateWithoutModelPricingInput> | Prisma.TokenUsageRecordCreateWithoutModelPricingInput[] | Prisma.TokenUsageRecordUncheckedCreateWithoutModelPricingInput[]
  connectOrCreate?: Prisma.TokenUsageRecordCreateOrConnectWithoutModelPricingInput | Prisma.TokenUsageRecordCreateOrConnectWithoutModelPricingInput[]
  upsert?: Prisma.TokenUsageRecordUpsertWithWhereUniqueWithoutModelPricingInput | Prisma.TokenUsageRecordUpsertWithWhereUniqueWithoutModelPricingInput[]
  createMany?: Prisma.TokenUsageRecordCreateManyModelPricingInputEnvelope
  set?: Prisma.TokenUsageRecordWhereUniqueInput | Prisma.TokenUsageRecordWhereUniqueInput[]
  disconnect?: Prisma.TokenUsageRecordWhereUniqueInput | Prisma.TokenUsageRecordWhereUniqueInput[]
  delete?: Prisma.TokenUsageRecordWhereUniqueInput | Prisma.TokenUsageRecordWhereUniqueInput[]
  connect?: Prisma.TokenUsageRecordWhereUniqueInput | Prisma.TokenUsageRecordWhereUniqueInput[]
  update?: Prisma.TokenUsageRecordUpdateWithWhereUniqueWithoutModelPricingInput | Prisma.TokenUsageRecordUpdateWithWhereUniqueWithoutModelPricingInput[]
  updateMany?: Prisma.TokenUsageRecordUpdateManyWithWhereWithoutModelPricingInput | Prisma.TokenUsageRecordUpdateManyWithWhereWithoutModelPricingInput[]
  deleteMany?: Prisma.TokenUsageRecordScalarWhereInput | Prisma.TokenUsageRecordScalarWhereInput[]
}

export type TokenUsageRecordUncheckedUpdateManyWithoutModelPricingNestedInput = {
  create?: Prisma.XOR<Prisma.TokenUsageRecordCreateWithoutModelPricingInput, Prisma.TokenUsageRecordUncheckedCreateWithoutModelPricingInput> | Prisma.TokenUsageRecordCreateWithoutModelPricingInput[] | Prisma.TokenUsageRecordUncheckedCreateWithoutModelPricingInput[]
  connectOrCreate?: Prisma.TokenUsageRecordCreateOrConnectWithoutModelPricingInput | Prisma.TokenUsageRecordCreateOrConnectWithoutModelPricingInput[]
  upsert?: Prisma.TokenUsageRecordUpsertWithWhereUniqueWithoutModelPricingInput | Prisma.TokenUsageRecordUpsertWithWhereUniqueWithoutModelPricingInput[]
  createMany?: Prisma.TokenUsageRecordCreateManyModelPricingInputEnvelope
  set?: Prisma.TokenUsageRecordWhereUniqueInput | Prisma.TokenUsageRecordWhereUniqueInput[]
  disconnect?: Prisma.TokenUsageRecordWhereUniqueInput | Prisma.TokenUsageRecordWhereUniqueInput[]
  delete?: Prisma.TokenUsageRecordWhereUniqueInput | Prisma.TokenUsageRecordWhereUniqueInput[]
  connect?: Prisma.TokenUsageRecordWhereUniqueInput | Prisma.TokenUsageRecordWhereUniqueInput[]
  update?: Prisma.TokenUsageRecordUpdateWithWhereUniqueWithoutModelPricingInput | Prisma.TokenUsageRecordUpdateWithWhereUniqueWithoutModelPricingInput[]
  updateMany?: Prisma.TokenUsageRecordUpdateManyWithWhereWithoutModelPricingInput | Prisma.TokenUsageRecordUpdateManyWithWhereWithoutModelPricingInput[]
  deleteMany?: Prisma.TokenUsageRecordScalarWhereInput | Prisma.TokenUsageRecordScalarWhereInput[]
}

export type IntFieldUpdateOperationsInput = {
  set?: number
  increment?: number
  decrement?: number
  multiply?: number
  divide?: number
}

export type TokenUsageRecordCreateWithoutUserInput = {
  id?: string
  promptTokens: number
  completionTokens: number
  totalTokens: number
  cachedTokens?: number
  reasoningTokens?: number
  createdAt?: Date | string
  updatedAt?: Date | string
  modelPricing: Prisma.ModelPricingCreateNestedOneWithoutTokenUsageRecordsInput
}

export type TokenUsageRecordUncheckedCreateWithoutUserInput = {
  id?: string
  modelPricingId: string
  promptTokens: number
  completionTokens: number
  totalTokens: number
  cachedTokens?: number
  reasoningTokens?: number
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type TokenUsageRecordCreateOrConnectWithoutUserInput = {
  where: Prisma.TokenUsageRecordWhereUniqueInput
  create: Prisma.XOR<Prisma.TokenUsageRecordCreateWithoutUserInput, Prisma.TokenUsageRecordUncheckedCreateWithoutUserInput>
}

export type TokenUsageRecordCreateManyUserInputEnvelope = {
  data: Prisma.TokenUsageRecordCreateManyUserInput | Prisma.TokenUsageRecordCreateManyUserInput[]
  skipDuplicates?: boolean
}

export type TokenUsageRecordUpsertWithWhereUniqueWithoutUserInput = {
  where: Prisma.TokenUsageRecordWhereUniqueInput
  update: Prisma.XOR<Prisma.TokenUsageRecordUpdateWithoutUserInput, Prisma.TokenUsageRecordUncheckedUpdateWithoutUserInput>
  create: Prisma.XOR<Prisma.TokenUsageRecordCreateWithoutUserInput, Prisma.TokenUsageRecordUncheckedCreateWithoutUserInput>
}

export type TokenUsageRecordUpdateWithWhereUniqueWithoutUserInput = {
  where: Prisma.TokenUsageRecordWhereUniqueInput
  data: Prisma.XOR<Prisma.TokenUsageRecordUpdateWithoutUserInput, Prisma.TokenUsageRecordUncheckedUpdateWithoutUserInput>
}

export type TokenUsageRecordUpdateManyWithWhereWithoutUserInput = {
  where: Prisma.TokenUsageRecordScalarWhereInput
  data: Prisma.XOR<Prisma.TokenUsageRecordUpdateManyMutationInput, Prisma.TokenUsageRecordUncheckedUpdateManyWithoutUserInput>
}

export type TokenUsageRecordScalarWhereInput = {
  AND?: Prisma.TokenUsageRecordScalarWhereInput | Prisma.TokenUsageRecordScalarWhereInput[]
  OR?: Prisma.TokenUsageRecordScalarWhereInput[]
  NOT?: Prisma.TokenUsageRecordScalarWhereInput | Prisma.TokenUsageRecordScalarWhereInput[]
  id?: Prisma.StringFilter<"TokenUsageRecord"> | string
  userId?: Prisma.StringFilter<"TokenUsageRecord"> | string
  modelPricingId?: Prisma.StringFilter<"TokenUsageRecord"> | string
  promptTokens?: Prisma.IntFilter<"TokenUsageRecord"> | number
  completionTokens?: Prisma.IntFilter<"TokenUsageRecord"> | number
  totalTokens?: Prisma.IntFilter<"TokenUsageRecord"> | number
  cachedTokens?: Prisma.IntFilter<"TokenUsageRecord"> | number
  reasoningTokens?: Prisma.IntFilter<"TokenUsageRecord"> | number
  createdAt?: Prisma.DateTimeFilter<"TokenUsageRecord"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"TokenUsageRecord"> | Date | string
}

export type TokenUsageRecordCreateWithoutModelPricingInput = {
  id?: string
  promptTokens: number
  completionTokens: number
  totalTokens: number
  cachedTokens?: number
  reasoningTokens?: number
  createdAt?: Date | string
  updatedAt?: Date | string
  user: Prisma.UserCreateNestedOneWithoutTokenUsageRecordsInput
}

export type TokenUsageRecordUncheckedCreateWithoutModelPricingInput = {
  id?: string
  userId: string
  promptTokens: number
  completionTokens: number
  totalTokens: number
  cachedTokens?: number
  reasoningTokens?: number
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type TokenUsageRecordCreateOrConnectWithoutModelPricingInput = {
  where: Prisma.TokenUsageRecordWhereUniqueInput
  create: Prisma.XOR<Prisma.TokenUsageRecordCreateWithoutModelPricingInput, Prisma.TokenUsageRecordUncheckedCreateWithoutModelPricingInput>
}

export type TokenUsageRecordCreateManyModelPricingInputEnvelope = {
  data: Prisma.TokenUsageRecordCreateManyModelPricingInput | Prisma.TokenUsageRecordCreateManyModelPricingInput[]
  skipDuplicates?: boolean
}

export type TokenUsageRecordUpsertWithWhereUniqueWithoutModelPricingInput = {
  where: Prisma.TokenUsageRecordWhereUniqueInput
  update: Prisma.XOR<Prisma.TokenUsageRecordUpdateWithoutModelPricingInput, Prisma.TokenUsageRecordUncheckedUpdateWithoutModelPricingInput>
  create: Prisma.XOR<Prisma.TokenUsageRecordCreateWithoutModelPricingInput, Prisma.TokenUsageRecordUncheckedCreateWithoutModelPricingInput>
}

export type TokenUsageRecordUpdateWithWhereUniqueWithoutModelPricingInput = {
  where: Prisma.TokenUsageRecordWhereUniqueInput
  data: Prisma.XOR<Prisma.TokenUsageRecordUpdateWithoutModelPricingInput, Prisma.TokenUsageRecordUncheckedUpdateWithoutModelPricingInput>
}

export type TokenUsageRecordUpdateManyWithWhereWithoutModelPricingInput = {
  where: Prisma.TokenUsageRecordScalarWhereInput
  data: Prisma.XOR<Prisma.TokenUsageRecordUpdateManyMutationInput, Prisma.TokenUsageRecordUncheckedUpdateManyWithoutModelPricingInput>
}

export type TokenUsageRecordCreateManyUserInput = {
  id?: string
  modelPricingId: string
  promptTokens: number
  completionTokens: number
  totalTokens: number
  cachedTokens?: number
  reasoningTokens?: number
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type TokenUsageRecordUpdateWithoutUserInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  promptTokens?: Prisma.IntFieldUpdateOperationsInput | number
  completionTokens?: Prisma.IntFieldUpdateOperationsInput | number
  totalTokens?: Prisma.IntFieldUpdateOperationsInput | number
  cachedTokens?: Prisma.IntFieldUpdateOperationsInput | number
  reasoningTokens?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  modelPricing?: Prisma.ModelPricingUpdateOneRequiredWithoutTokenUsageRecordsNestedInput
}

export type TokenUsageRecordUncheckedUpdateWithoutUserInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  modelPricingId?: Prisma.StringFieldUpdateOperationsInput | string
  promptTokens?: Prisma.IntFieldUpdateOperationsInput | number
  completionTokens?: Prisma.IntFieldUpdateOperationsInput | number
  totalTokens?: Prisma.IntFieldUpdateOperationsInput | number
  cachedTokens?: Prisma.IntFieldUpdateOperationsInput | number
  reasoningTokens?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type TokenUsageRecordUncheckedUpdateManyWithoutUserInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  modelPricingId?: Prisma.StringFieldUpdateOperationsInput | string
  promptTokens?: Prisma.IntFieldUpdateOperationsInput | number
  completionTokens?: Prisma.IntFieldUpdateOperationsInput | number
  totalTokens?: Prisma.IntFieldUpdateOperationsInput | number
  cachedTokens?: Prisma.IntFieldUpdateOperationsInput | number
  reasoningTokens?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type TokenUsageRecordCreateManyModelPricingInput = {
  id?: string
  userId: string
  promptTokens: number
  completionTokens: number
  totalTokens: number
  cachedTokens?: number
  reasoningTokens?: number
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type TokenUsageRecordUpdateWithoutModelPricingInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  promptTokens?: Prisma.IntFieldUpdateOperationsInput | number
  completionTokens?: Prisma.IntFieldUpdateOperationsInput | number
  totalTokens?: Prisma.IntFieldUpdateOperationsInput | number
  cachedTokens?: Prisma.IntFieldUpdateOperationsInput | number
  reasoningTokens?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  user?: Prisma.UserUpdateOneRequiredWithoutTokenUsageRecordsNestedInput
}

export type TokenUsageRecordUncheckedUpdateWithoutModelPricingInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  promptTokens?: Prisma.IntFieldUpdateOperationsInput | number
  completionTokens?: Prisma.IntFieldUpdateOperationsInput | number
  totalTokens?: Prisma.IntFieldUpdateOperationsInput | number
  cachedTokens?: Prisma.IntFieldUpdateOperationsInput | number
  reasoningTokens?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type TokenUsageRecordUncheckedUpdateManyWithoutModelPricingInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  promptTokens?: Prisma.IntFieldUpdateOperationsInput | number
  completionTokens?: Prisma.IntFieldUpdateOperationsInput | number
  totalTokens?: Prisma.IntFieldUpdateOperationsInput | number
  cachedTokens?: Prisma.IntFieldUpdateOperationsInput | number
  reasoningTokens?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}



export type TokenUsageRecordSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  userId?: boolean
  modelPricingId?: boolean
  promptTokens?: boolean
  completionTokens?: boolean
  totalTokens?: boolean
  cachedTokens?: boolean
  reasoningTokens?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  modelPricing?: boolean | Prisma.ModelPricingDefaultArgs<ExtArgs>
}, ExtArgs["result"]["tokenUsageRecord"]>

export type TokenUsageRecordSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  userId?: boolean
  modelPricingId?: boolean
  promptTokens?: boolean
  completionTokens?: boolean
  totalTokens?: boolean
  cachedTokens?: boolean
  reasoningTokens?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  modelPricing?: boolean | Prisma.ModelPricingDefaultArgs<ExtArgs>
}, ExtArgs["result"]["tokenUsageRecord"]>

export type TokenUsageRecordSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  userId?: boolean
  modelPricingId?: boolean
  promptTokens?: boolean
  completionTokens?: boolean
  totalTokens?: boolean
  cachedTokens?: boolean
  reasoningTokens?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  modelPricing?: boolean | Prisma.ModelPricingDefaultArgs<ExtArgs>
}, ExtArgs["result"]["tokenUsageRecord"]>

export type TokenUsageRecordSelectScalar = {
  id?: boolean
  userId?: boolean
  modelPricingId?: boolean
  promptTokens?: boolean
  completionTokens?: boolean
  totalTokens?: boolean
  cachedTokens?: boolean
  reasoningTokens?: boolean
  createdAt?: boolean
  updatedAt?: boolean
}

export type TokenUsageRecordOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "userId" | "modelPricingId" | "promptTokens" | "completionTokens" | "totalTokens" | "cachedTokens" | "reasoningTokens" | "createdAt" | "updatedAt", ExtArgs["result"]["tokenUsageRecord"]>
export type TokenUsageRecordInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  modelPricing?: boolean | Prisma.ModelPricingDefaultArgs<ExtArgs>
}
export type TokenUsageRecordIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  modelPricing?: boolean | Prisma.ModelPricingDefaultArgs<ExtArgs>
}
export type TokenUsageRecordIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  modelPricing?: boolean | Prisma.ModelPricingDefaultArgs<ExtArgs>
}

export type $TokenUsageRecordPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "TokenUsageRecord"
  objects: {
    user: Prisma.$UserPayload<ExtArgs>
    modelPricing: Prisma.$ModelPricingPayload<ExtArgs>
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: string
    userId: string
    modelPricingId: string
    promptTokens: number
    completionTokens: number
    totalTokens: number
    cachedTokens: number
    reasoningTokens: number
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["tokenUsageRecord"]>
  composites: {}
}

export type TokenUsageRecordGetPayload<S extends boolean | null | undefined | TokenUsageRecordDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$TokenUsageRecordPayload, S>

export type TokenUsageRecordCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<TokenUsageRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: TokenUsageRecordCountAggregateInputType | true
  }

export interface TokenUsageRecordDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TokenUsageRecord'], meta: { name: 'TokenUsageRecord' } }
  /**
   * Find zero or one TokenUsageRecord that matches the filter.
   * @param {TokenUsageRecordFindUniqueArgs} args - Arguments to find a TokenUsageRecord
   * @example
   * // Get one TokenUsageRecord
   * const tokenUsageRecord = await prisma.tokenUsageRecord.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends TokenUsageRecordFindUniqueArgs>(args: Prisma.SelectSubset<T, TokenUsageRecordFindUniqueArgs<ExtArgs>>): Prisma.Prisma__TokenUsageRecordClient<runtime.Types.Result.GetResult<Prisma.$TokenUsageRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one TokenUsageRecord that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {TokenUsageRecordFindUniqueOrThrowArgs} args - Arguments to find a TokenUsageRecord
   * @example
   * // Get one TokenUsageRecord
   * const tokenUsageRecord = await prisma.tokenUsageRecord.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends TokenUsageRecordFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, TokenUsageRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__TokenUsageRecordClient<runtime.Types.Result.GetResult<Prisma.$TokenUsageRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first TokenUsageRecord that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {TokenUsageRecordFindFirstArgs} args - Arguments to find a TokenUsageRecord
   * @example
   * // Get one TokenUsageRecord
   * const tokenUsageRecord = await prisma.tokenUsageRecord.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends TokenUsageRecordFindFirstArgs>(args?: Prisma.SelectSubset<T, TokenUsageRecordFindFirstArgs<ExtArgs>>): Prisma.Prisma__TokenUsageRecordClient<runtime.Types.Result.GetResult<Prisma.$TokenUsageRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first TokenUsageRecord that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {TokenUsageRecordFindFirstOrThrowArgs} args - Arguments to find a TokenUsageRecord
   * @example
   * // Get one TokenUsageRecord
   * const tokenUsageRecord = await prisma.tokenUsageRecord.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends TokenUsageRecordFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, TokenUsageRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__TokenUsageRecordClient<runtime.Types.Result.GetResult<Prisma.$TokenUsageRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more TokenUsageRecords that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {TokenUsageRecordFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all TokenUsageRecords
   * const tokenUsageRecords = await prisma.tokenUsageRecord.findMany()
   * 
   * // Get first 10 TokenUsageRecords
   * const tokenUsageRecords = await prisma.tokenUsageRecord.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const tokenUsageRecordWithIdOnly = await prisma.tokenUsageRecord.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends TokenUsageRecordFindManyArgs>(args?: Prisma.SelectSubset<T, TokenUsageRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$TokenUsageRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a TokenUsageRecord.
   * @param {TokenUsageRecordCreateArgs} args - Arguments to create a TokenUsageRecord.
   * @example
   * // Create one TokenUsageRecord
   * const TokenUsageRecord = await prisma.tokenUsageRecord.create({
   *   data: {
   *     // ... data to create a TokenUsageRecord
   *   }
   * })
   * 
   */
  create<T extends TokenUsageRecordCreateArgs>(args: Prisma.SelectSubset<T, TokenUsageRecordCreateArgs<ExtArgs>>): Prisma.Prisma__TokenUsageRecordClient<runtime.Types.Result.GetResult<Prisma.$TokenUsageRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many TokenUsageRecords.
   * @param {TokenUsageRecordCreateManyArgs} args - Arguments to create many TokenUsageRecords.
   * @example
   * // Create many TokenUsageRecords
   * const tokenUsageRecord = await prisma.tokenUsageRecord.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends TokenUsageRecordCreateManyArgs>(args?: Prisma.SelectSubset<T, TokenUsageRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many TokenUsageRecords and returns the data saved in the database.
   * @param {TokenUsageRecordCreateManyAndReturnArgs} args - Arguments to create many TokenUsageRecords.
   * @example
   * // Create many TokenUsageRecords
   * const tokenUsageRecord = await prisma.tokenUsageRecord.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many TokenUsageRecords and only return the `id`
   * const tokenUsageRecordWithIdOnly = await prisma.tokenUsageRecord.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends TokenUsageRecordCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, TokenUsageRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$TokenUsageRecordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a TokenUsageRecord.
   * @param {TokenUsageRecordDeleteArgs} args - Arguments to delete one TokenUsageRecord.
   * @example
   * // Delete one TokenUsageRecord
   * const TokenUsageRecord = await prisma.tokenUsageRecord.delete({
   *   where: {
   *     // ... filter to delete one TokenUsageRecord
   *   }
   * })
   * 
   */
  delete<T extends TokenUsageRecordDeleteArgs>(args: Prisma.SelectSubset<T, TokenUsageRecordDeleteArgs<ExtArgs>>): Prisma.Prisma__TokenUsageRecordClient<runtime.Types.Result.GetResult<Prisma.$TokenUsageRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one TokenUsageRecord.
   * @param {TokenUsageRecordUpdateArgs} args - Arguments to update one TokenUsageRecord.
   * @example
   * // Update one TokenUsageRecord
   * const tokenUsageRecord = await prisma.tokenUsageRecord.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends TokenUsageRecordUpdateArgs>(args: Prisma.SelectSubset<T, TokenUsageRecordUpdateArgs<ExtArgs>>): Prisma.Prisma__TokenUsageRecordClient<runtime.Types.Result.GetResult<Prisma.$TokenUsageRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more TokenUsageRecords.
   * @param {TokenUsageRecordDeleteManyArgs} args - Arguments to filter TokenUsageRecords to delete.
   * @example
   * // Delete a few TokenUsageRecords
   * const { count } = await prisma.tokenUsageRecord.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends TokenUsageRecordDeleteManyArgs>(args?: Prisma.SelectSubset<T, TokenUsageRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more TokenUsageRecords.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {TokenUsageRecordUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many TokenUsageRecords
   * const tokenUsageRecord = await prisma.tokenUsageRecord.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends TokenUsageRecordUpdateManyArgs>(args: Prisma.SelectSubset<T, TokenUsageRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more TokenUsageRecords and returns the data updated in the database.
   * @param {TokenUsageRecordUpdateManyAndReturnArgs} args - Arguments to update many TokenUsageRecords.
   * @example
   * // Update many TokenUsageRecords
   * const tokenUsageRecord = await prisma.tokenUsageRecord.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more TokenUsageRecords and only return the `id`
   * const tokenUsageRecordWithIdOnly = await prisma.tokenUsageRecord.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends TokenUsageRecordUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, TokenUsageRecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$TokenUsageRecordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one TokenUsageRecord.
   * @param {TokenUsageRecordUpsertArgs} args - Arguments to update or create a TokenUsageRecord.
   * @example
   * // Update or create a TokenUsageRecord
   * const tokenUsageRecord = await prisma.tokenUsageRecord.upsert({
   *   create: {
   *     // ... data to create a TokenUsageRecord
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the TokenUsageRecord we want to update
   *   }
   * })
   */
  upsert<T extends TokenUsageRecordUpsertArgs>(args: Prisma.SelectSubset<T, TokenUsageRecordUpsertArgs<ExtArgs>>): Prisma.Prisma__TokenUsageRecordClient<runtime.Types.Result.GetResult<Prisma.$TokenUsageRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of TokenUsageRecords.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {TokenUsageRecordCountArgs} args - Arguments to filter TokenUsageRecords to count.
   * @example
   * // Count the number of TokenUsageRecords
   * const count = await prisma.tokenUsageRecord.count({
   *   where: {
   *     // ... the filter for the TokenUsageRecords we want to count
   *   }
   * })
  **/
  count<T extends TokenUsageRecordCountArgs>(
    args?: Prisma.Subset<T, TokenUsageRecordCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], TokenUsageRecordCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a TokenUsageRecord.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {TokenUsageRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends TokenUsageRecordAggregateArgs>(args: Prisma.Subset<T, TokenUsageRecordAggregateArgs>): Prisma.PrismaPromise<GetTokenUsageRecordAggregateType<T>>

  /**
   * Group by TokenUsageRecord.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {TokenUsageRecordGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends TokenUsageRecordGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: TokenUsageRecordGroupByArgs['orderBy'] }
      : { orderBy?: TokenUsageRecordGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, TokenUsageRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTokenUsageRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the TokenUsageRecord model
 */
readonly fields: TokenUsageRecordFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for TokenUsageRecord.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__TokenUsageRecordClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  user<T extends Prisma.UserDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.UserDefaultArgs<ExtArgs>>): Prisma.Prisma__UserClient<runtime.Types.Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  modelPricing<T extends Prisma.ModelPricingDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.ModelPricingDefaultArgs<ExtArgs>>): Prisma.Prisma__ModelPricingClient<runtime.Types.Result.GetResult<Prisma.$ModelPricingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the TokenUsageRecord model
 */
export interface TokenUsageRecordFieldRefs {
  readonly id: Prisma.FieldRef<"TokenUsageRecord", 'String'>
  readonly userId: Prisma.FieldRef<"TokenUsageRecord", 'String'>
  readonly modelPricingId: Prisma.FieldRef<"TokenUsageRecord", 'String'>
  readonly promptTokens: Prisma.FieldRef<"TokenUsageRecord", 'Int'>
  readonly completionTokens: Prisma.FieldRef<"TokenUsageRecord", 'Int'>
  readonly totalTokens: Prisma.FieldRef<"TokenUsageRecord", 'Int'>
  readonly cachedTokens: Prisma.FieldRef<"TokenUsageRecord", 'Int'>
  readonly reasoningTokens: Prisma.FieldRef<"TokenUsageRecord", 'Int'>
  readonly createdAt: Prisma.FieldRef<"TokenUsageRecord", 'DateTime'>
  readonly updatedAt: Prisma.FieldRef<"TokenUsageRecord", 'DateTime'>
}
    

// Custom InputTypes
/**
 * TokenUsageRecord findUnique
 */
export type TokenUsageRecordFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the TokenUsageRecord
   */
  select?: Prisma.TokenUsageRecordSelect<ExtArgs> | null
  /**
   * Omit specific fields from the TokenUsageRecord
   */
  omit?: Prisma.TokenUsageRecordOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TokenUsageRecordInclude<ExtArgs> | null
  /**
   * Filter, which TokenUsageRecord to fetch.
   */
  where: Prisma.TokenUsageRecordWhereUniqueInput
}

/**
 * TokenUsageRecord findUniqueOrThrow
 */
export type TokenUsageRecordFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the TokenUsageRecord
   */
  select?: Prisma.TokenUsageRecordSelect<ExtArgs> | null
  /**
   * Omit specific fields from the TokenUsageRecord
   */
  omit?: Prisma.TokenUsageRecordOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TokenUsageRecordInclude<ExtArgs> | null
  /**
   * Filter, which TokenUsageRecord to fetch.
   */
  where: Prisma.TokenUsageRecordWhereUniqueInput
}

/**
 * TokenUsageRecord findFirst
 */
export type TokenUsageRecordFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the TokenUsageRecord
   */
  select?: Prisma.TokenUsageRecordSelect<ExtArgs> | null
  /**
   * Omit specific fields from the TokenUsageRecord
   */
  omit?: Prisma.TokenUsageRecordOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TokenUsageRecordInclude<ExtArgs> | null
  /**
   * Filter, which TokenUsageRecord to fetch.
   */
  where?: Prisma.TokenUsageRecordWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of TokenUsageRecords to fetch.
   */
  orderBy?: Prisma.TokenUsageRecordOrderByWithRelationInput | Prisma.TokenUsageRecordOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for TokenUsageRecords.
   */
  cursor?: Prisma.TokenUsageRecordWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` TokenUsageRecords from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` TokenUsageRecords.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of TokenUsageRecords.
   */
  distinct?: Prisma.TokenUsageRecordScalarFieldEnum | Prisma.TokenUsageRecordScalarFieldEnum[]
}

/**
 * TokenUsageRecord findFirstOrThrow
 */
export type TokenUsageRecordFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the TokenUsageRecord
   */
  select?: Prisma.TokenUsageRecordSelect<ExtArgs> | null
  /**
   * Omit specific fields from the TokenUsageRecord
   */
  omit?: Prisma.TokenUsageRecordOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TokenUsageRecordInclude<ExtArgs> | null
  /**
   * Filter, which TokenUsageRecord to fetch.
   */
  where?: Prisma.TokenUsageRecordWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of TokenUsageRecords to fetch.
   */
  orderBy?: Prisma.TokenUsageRecordOrderByWithRelationInput | Prisma.TokenUsageRecordOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for TokenUsageRecords.
   */
  cursor?: Prisma.TokenUsageRecordWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` TokenUsageRecords from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` TokenUsageRecords.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of TokenUsageRecords.
   */
  distinct?: Prisma.TokenUsageRecordScalarFieldEnum | Prisma.TokenUsageRecordScalarFieldEnum[]
}

/**
 * TokenUsageRecord findMany
 */
export type TokenUsageRecordFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the TokenUsageRecord
   */
  select?: Prisma.TokenUsageRecordSelect<ExtArgs> | null
  /**
   * Omit specific fields from the TokenUsageRecord
   */
  omit?: Prisma.TokenUsageRecordOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TokenUsageRecordInclude<ExtArgs> | null
  /**
   * Filter, which TokenUsageRecords to fetch.
   */
  where?: Prisma.TokenUsageRecordWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of TokenUsageRecords to fetch.
   */
  orderBy?: Prisma.TokenUsageRecordOrderByWithRelationInput | Prisma.TokenUsageRecordOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing TokenUsageRecords.
   */
  cursor?: Prisma.TokenUsageRecordWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` TokenUsageRecords from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` TokenUsageRecords.
   */
  skip?: number
  distinct?: Prisma.TokenUsageRecordScalarFieldEnum | Prisma.TokenUsageRecordScalarFieldEnum[]
}

/**
 * TokenUsageRecord create
 */
export type TokenUsageRecordCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the TokenUsageRecord
   */
  select?: Prisma.TokenUsageRecordSelect<ExtArgs> | null
  /**
   * Omit specific fields from the TokenUsageRecord
   */
  omit?: Prisma.TokenUsageRecordOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TokenUsageRecordInclude<ExtArgs> | null
  /**
   * The data needed to create a TokenUsageRecord.
   */
  data: Prisma.XOR<Prisma.TokenUsageRecordCreateInput, Prisma.TokenUsageRecordUncheckedCreateInput>
}

/**
 * TokenUsageRecord createMany
 */
export type TokenUsageRecordCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many TokenUsageRecords.
   */
  data: Prisma.TokenUsageRecordCreateManyInput | Prisma.TokenUsageRecordCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * TokenUsageRecord createManyAndReturn
 */
export type TokenUsageRecordCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the TokenUsageRecord
   */
  select?: Prisma.TokenUsageRecordSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the TokenUsageRecord
   */
  omit?: Prisma.TokenUsageRecordOmit<ExtArgs> | null
  /**
   * The data used to create many TokenUsageRecords.
   */
  data: Prisma.TokenUsageRecordCreateManyInput | Prisma.TokenUsageRecordCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TokenUsageRecordIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * TokenUsageRecord update
 */
export type TokenUsageRecordUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the TokenUsageRecord
   */
  select?: Prisma.TokenUsageRecordSelect<ExtArgs> | null
  /**
   * Omit specific fields from the TokenUsageRecord
   */
  omit?: Prisma.TokenUsageRecordOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TokenUsageRecordInclude<ExtArgs> | null
  /**
   * The data needed to update a TokenUsageRecord.
   */
  data: Prisma.XOR<Prisma.TokenUsageRecordUpdateInput, Prisma.TokenUsageRecordUncheckedUpdateInput>
  /**
   * Choose, which TokenUsageRecord to update.
   */
  where: Prisma.TokenUsageRecordWhereUniqueInput
}

/**
 * TokenUsageRecord updateMany
 */
export type TokenUsageRecordUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update TokenUsageRecords.
   */
  data: Prisma.XOR<Prisma.TokenUsageRecordUpdateManyMutationInput, Prisma.TokenUsageRecordUncheckedUpdateManyInput>
  /**
   * Filter which TokenUsageRecords to update
   */
  where?: Prisma.TokenUsageRecordWhereInput
  /**
   * Limit how many TokenUsageRecords to update.
   */
  limit?: number
}

/**
 * TokenUsageRecord updateManyAndReturn
 */
export type TokenUsageRecordUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the TokenUsageRecord
   */
  select?: Prisma.TokenUsageRecordSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the TokenUsageRecord
   */
  omit?: Prisma.TokenUsageRecordOmit<ExtArgs> | null
  /**
   * The data used to update TokenUsageRecords.
   */
  data: Prisma.XOR<Prisma.TokenUsageRecordUpdateManyMutationInput, Prisma.TokenUsageRecordUncheckedUpdateManyInput>
  /**
   * Filter which TokenUsageRecords to update
   */
  where?: Prisma.TokenUsageRecordWhereInput
  /**
   * Limit how many TokenUsageRecords to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TokenUsageRecordIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * TokenUsageRecord upsert
 */
export type TokenUsageRecordUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the TokenUsageRecord
   */
  select?: Prisma.TokenUsageRecordSelect<ExtArgs> | null
  /**
   * Omit specific fields from the TokenUsageRecord
   */
  omit?: Prisma.TokenUsageRecordOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TokenUsageRecordInclude<ExtArgs> | null
  /**
   * The filter to search for the TokenUsageRecord to update in case it exists.
   */
  where: Prisma.TokenUsageRecordWhereUniqueInput
  /**
   * In case the TokenUsageRecord found by the `where` argument doesn't exist, create a new TokenUsageRecord with this data.
   */
  create: Prisma.XOR<Prisma.TokenUsageRecordCreateInput, Prisma.TokenUsageRecordUncheckedCreateInput>
  /**
   * In case the TokenUsageRecord was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.TokenUsageRecordUpdateInput, Prisma.TokenUsageRecordUncheckedUpdateInput>
}

/**
 * TokenUsageRecord delete
 */
export type TokenUsageRecordDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the TokenUsageRecord
   */
  select?: Prisma.TokenUsageRecordSelect<ExtArgs> | null
  /**
   * Omit specific fields from the TokenUsageRecord
   */
  omit?: Prisma.TokenUsageRecordOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TokenUsageRecordInclude<ExtArgs> | null
  /**
   * Filter which TokenUsageRecord to delete.
   */
  where: Prisma.TokenUsageRecordWhereUniqueInput
}

/**
 * TokenUsageRecord deleteMany
 */
export type TokenUsageRecordDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which TokenUsageRecords to delete
   */
  where?: Prisma.TokenUsageRecordWhereInput
  /**
   * Limit how many TokenUsageRecords to delete.
   */
  limit?: number
}

/**
 * TokenUsageRecord without action
 */
export type TokenUsageRecordDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the TokenUsageRecord
   */
  select?: Prisma.TokenUsageRecordSelect<ExtArgs> | null
  /**
   * Omit specific fields from the TokenUsageRecord
   */
  omit?: Prisma.TokenUsageRecordOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TokenUsageRecordInclude<ExtArgs> | null
}
