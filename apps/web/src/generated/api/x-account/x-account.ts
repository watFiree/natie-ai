/**
 * Generated by orval v8.2.0 ðŸº
 * Do not edit manually.
 * API
 * API documentation
 * OpenAPI spec version: 1.0.0
 */
import { useInfiniteQuery, useMutation, useQuery } from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'

import type {
  DeleteXAccount200,
  SaveXAccountInput,
  XAccount,
} from '../../model'

import { customInstance } from '../../../lib/axios-instance'

/**
 * @summary Get X account for current user
 */
export type getXAccountResponse200 = {
  data: XAccount
  status: 200
}

export type getXAccountResponse401 = {
  data: void
  status: 401
}

export type getXAccountResponse404 = {
  data: void
  status: 404
}

export type getXAccountResponseSuccess = getXAccountResponse200 & {
  headers: Headers
}
export type getXAccountResponseError = (
  | getXAccountResponse401
  | getXAccountResponse404
) & {
  headers: Headers
}

export type getXAccountResponse =
  | getXAccountResponseSuccess
  | getXAccountResponseError

export const getGetXAccountUrl = () => {
  return `/x-account`
}

export const getXAccount = async (
  options?: RequestInit,
): Promise<getXAccountResponse> => {
  return customInstance<getXAccountResponse>(getGetXAccountUrl(), {
    ...options,
    method: 'GET',
  })
}

export const getGetXAccountInfiniteQueryKey = () => {
  return ['infinite', `/x-account`] as const
}

export const getGetXAccountQueryKey = () => {
  return [`/x-account`] as const
}

export const getGetXAccountInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getXAccount>>>,
  TError = void,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof getXAccount>>,
      TError,
      TData
    >
  >
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetXAccountInfiniteQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getXAccount>>> = ({
    signal,
  }) => getXAccount({ signal })

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getXAccount>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetXAccountInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getXAccount>>
>
export type GetXAccountInfiniteQueryError = void

export function useGetXAccountInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getXAccount>>>,
  TError = void,
>(
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getXAccount>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getXAccount>>,
          TError,
          Awaited<ReturnType<typeof getXAccount>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetXAccountInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getXAccount>>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getXAccount>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getXAccount>>,
          TError,
          Awaited<ReturnType<typeof getXAccount>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetXAccountInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getXAccount>>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getXAccount>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get X account for current user
 */

export function useGetXAccountInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getXAccount>>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getXAccount>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetXAccountInfiniteQueryOptions(options)

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

export const getGetXAccountQueryOptions = <
  TData = Awaited<ReturnType<typeof getXAccount>>,
  TError = void,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getXAccount>>, TError, TData>
  >
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetXAccountQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getXAccount>>> = ({
    signal,
  }) => getXAccount({ signal })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getXAccount>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetXAccountQueryResult = NonNullable<
  Awaited<ReturnType<typeof getXAccount>>
>
export type GetXAccountQueryError = void

export function useGetXAccount<
  TData = Awaited<ReturnType<typeof getXAccount>>,
  TError = void,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getXAccount>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getXAccount>>,
          TError,
          Awaited<ReturnType<typeof getXAccount>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetXAccount<
  TData = Awaited<ReturnType<typeof getXAccount>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getXAccount>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getXAccount>>,
          TError,
          Awaited<ReturnType<typeof getXAccount>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetXAccount<
  TData = Awaited<ReturnType<typeof getXAccount>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getXAccount>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get X account for current user
 */

export function useGetXAccount<
  TData = Awaited<ReturnType<typeof getXAccount>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getXAccount>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetXAccountQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  return { ...query, queryKey: queryOptions.queryKey }
}

/**
 * @summary Save or update X account
 */
export type saveXAccountResponse200 = {
  data: XAccount
  status: 200
}

export type saveXAccountResponse401 = {
  data: void
  status: 401
}

export type saveXAccountResponseSuccess = saveXAccountResponse200 & {
  headers: Headers
}
export type saveXAccountResponseError = saveXAccountResponse401 & {
  headers: Headers
}

export type saveXAccountResponse =
  | saveXAccountResponseSuccess
  | saveXAccountResponseError

export const getSaveXAccountUrl = () => {
  return `/x-account`
}

export const saveXAccount = async (
  saveXAccountInput: SaveXAccountInput,
  options?: RequestInit,
): Promise<saveXAccountResponse> => {
  return customInstance<saveXAccountResponse>(getSaveXAccountUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(saveXAccountInput),
  })
}

export const getSaveXAccountMutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof saveXAccount>>,
    TError,
    { data: SaveXAccountInput },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof saveXAccount>>,
  TError,
  { data: SaveXAccountInput },
  TContext
> => {
  const mutationKey = ['saveXAccount']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof saveXAccount>>,
    { data: SaveXAccountInput }
  > = (props) => {
    const { data } = props ?? {}

    return saveXAccount(data)
  }

  return { mutationFn, ...mutationOptions }
}

export type SaveXAccountMutationResult = NonNullable<
  Awaited<ReturnType<typeof saveXAccount>>
>
export type SaveXAccountMutationBody = SaveXAccountInput
export type SaveXAccountMutationError = void

/**
 * @summary Save or update X account
 */
export const useSaveXAccount = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof saveXAccount>>,
      TError,
      { data: SaveXAccountInput },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof saveXAccount>>,
  TError,
  { data: SaveXAccountInput },
  TContext
> => {
  return useMutation(getSaveXAccountMutationOptions(options), queryClient)
}
/**
 * @summary Delete X account
 */
export type deleteXAccountResponse200 = {
  data: DeleteXAccount200
  status: 200
}

export type deleteXAccountResponse401 = {
  data: void
  status: 401
}

export type deleteXAccountResponse404 = {
  data: void
  status: 404
}

export type deleteXAccountResponseSuccess = deleteXAccountResponse200 & {
  headers: Headers
}
export type deleteXAccountResponseError = (
  | deleteXAccountResponse401
  | deleteXAccountResponse404
) & {
  headers: Headers
}

export type deleteXAccountResponse =
  | deleteXAccountResponseSuccess
  | deleteXAccountResponseError

export const getDeleteXAccountUrl = () => {
  return `/x-account`
}

export const deleteXAccount = async (
  options?: RequestInit,
): Promise<deleteXAccountResponse> => {
  return customInstance<deleteXAccountResponse>(getDeleteXAccountUrl(), {
    ...options,
    method: 'DELETE',
  })
}

export const getDeleteXAccountMutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteXAccount>>,
    TError,
    void,
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteXAccount>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ['deleteXAccount']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteXAccount>>,
    void
  > = () => {
    return deleteXAccount()
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteXAccountMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteXAccount>>
>

export type DeleteXAccountMutationError = void

/**
 * @summary Delete X account
 */
export const useDeleteXAccount = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteXAccount>>,
      TError,
      void,
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteXAccount>>,
  TError,
  void,
  TContext
> => {
  return useMutation(getDeleteXAccountMutationOptions(options), queryClient)
}
