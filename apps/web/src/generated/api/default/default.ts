/**
 * Generated by orval v8.2.0 ðŸº
 * Do not edit manually.
 * API
 * API documentation
 * OpenAPI spec version: 1.0.0
 */
import {
  useInfiniteQuery,
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  PostEmailChatBody,
  PostEmailCreateBody,
  PostXAccountBody,
  PostXChatBody,
  PostXCreateBody
} from '../../model';

import { customInstance } from '../../../lib/axios-instance';




export type getAuthLoginResponse200 = {
  data: void
  status: 200
}
    
export type getAuthLoginResponseSuccess = (getAuthLoginResponse200) & {
  headers: Headers;
};
;

export type getAuthLoginResponse = (getAuthLoginResponseSuccess)

export const getGetAuthLoginUrl = () => {


  

  return `/auth/login`
}

export const getAuthLogin = async ( options?: RequestInit): Promise<getAuthLoginResponse> => {
  
  return customInstance<getAuthLoginResponse>(getGetAuthLoginUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetAuthLoginInfiniteQueryKey = () => {
    return [
    'infinite', `/auth/login`
    ] as const;
    }

export const getGetAuthLoginQueryKey = () => {
    return [
    `/auth/login`
    ] as const;
    }

    
export const getGetAuthLoginInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAuthLogin>>>, TError = unknown>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAuthLogin>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAuthLoginInfiniteQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAuthLogin>>> = ({ signal }) => getAuthLogin({ signal });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAuthLogin>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAuthLoginInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAuthLogin>>>
export type GetAuthLoginInfiniteQueryError = unknown


export function useGetAuthLoginInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAuthLogin>>>, TError = unknown>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAuthLogin>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAuthLogin>>,
          TError,
          Awaited<ReturnType<typeof getAuthLogin>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAuthLoginInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAuthLogin>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAuthLogin>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAuthLogin>>,
          TError,
          Awaited<ReturnType<typeof getAuthLogin>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAuthLoginInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAuthLogin>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAuthLogin>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetAuthLoginInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAuthLogin>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAuthLogin>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAuthLoginInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




export const getGetAuthLoginQueryOptions = <TData = Awaited<ReturnType<typeof getAuthLogin>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthLogin>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAuthLoginQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAuthLogin>>> = ({ signal }) => getAuthLogin({ signal });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAuthLogin>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAuthLoginQueryResult = NonNullable<Awaited<ReturnType<typeof getAuthLogin>>>
export type GetAuthLoginQueryError = unknown


export function useGetAuthLogin<TData = Awaited<ReturnType<typeof getAuthLogin>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthLogin>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAuthLogin>>,
          TError,
          Awaited<ReturnType<typeof getAuthLogin>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAuthLogin<TData = Awaited<ReturnType<typeof getAuthLogin>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthLogin>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAuthLogin>>,
          TError,
          Awaited<ReturnType<typeof getAuthLogin>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAuthLogin<TData = Awaited<ReturnType<typeof getAuthLogin>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthLogin>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetAuthLogin<TData = Awaited<ReturnType<typeof getAuthLogin>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthLogin>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAuthLoginQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




export type getAuthCallbackResponse200 = {
  data: void
  status: 200
}
    
export type getAuthCallbackResponseSuccess = (getAuthCallbackResponse200) & {
  headers: Headers;
};
;

export type getAuthCallbackResponse = (getAuthCallbackResponseSuccess)

export const getGetAuthCallbackUrl = () => {


  

  return `/auth/callback`
}

export const getAuthCallback = async ( options?: RequestInit): Promise<getAuthCallbackResponse> => {
  
  return customInstance<getAuthCallbackResponse>(getGetAuthCallbackUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetAuthCallbackInfiniteQueryKey = () => {
    return [
    'infinite', `/auth/callback`
    ] as const;
    }

export const getGetAuthCallbackQueryKey = () => {
    return [
    `/auth/callback`
    ] as const;
    }

    
export const getGetAuthCallbackInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAuthCallback>>>, TError = unknown>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAuthCallback>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAuthCallbackInfiniteQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAuthCallback>>> = ({ signal }) => getAuthCallback({ signal });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAuthCallback>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAuthCallbackInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAuthCallback>>>
export type GetAuthCallbackInfiniteQueryError = unknown


export function useGetAuthCallbackInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAuthCallback>>>, TError = unknown>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAuthCallback>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAuthCallback>>,
          TError,
          Awaited<ReturnType<typeof getAuthCallback>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAuthCallbackInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAuthCallback>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAuthCallback>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAuthCallback>>,
          TError,
          Awaited<ReturnType<typeof getAuthCallback>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAuthCallbackInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAuthCallback>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAuthCallback>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetAuthCallbackInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAuthCallback>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAuthCallback>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAuthCallbackInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




export const getGetAuthCallbackQueryOptions = <TData = Awaited<ReturnType<typeof getAuthCallback>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthCallback>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAuthCallbackQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAuthCallback>>> = ({ signal }) => getAuthCallback({ signal });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAuthCallback>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAuthCallbackQueryResult = NonNullable<Awaited<ReturnType<typeof getAuthCallback>>>
export type GetAuthCallbackQueryError = unknown


export function useGetAuthCallback<TData = Awaited<ReturnType<typeof getAuthCallback>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthCallback>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAuthCallback>>,
          TError,
          Awaited<ReturnType<typeof getAuthCallback>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAuthCallback<TData = Awaited<ReturnType<typeof getAuthCallback>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthCallback>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAuthCallback>>,
          TError,
          Awaited<ReturnType<typeof getAuthCallback>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAuthCallback<TData = Awaited<ReturnType<typeof getAuthCallback>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthCallback>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetAuthCallback<TData = Awaited<ReturnType<typeof getAuthCallback>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthCallback>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAuthCallbackQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




export type getAuthStatusResponse200 = {
  data: void
  status: 200
}
    
export type getAuthStatusResponseSuccess = (getAuthStatusResponse200) & {
  headers: Headers;
};
;

export type getAuthStatusResponse = (getAuthStatusResponseSuccess)

export const getGetAuthStatusUrl = () => {


  

  return `/auth/status`
}

export const getAuthStatus = async ( options?: RequestInit): Promise<getAuthStatusResponse> => {
  
  return customInstance<getAuthStatusResponse>(getGetAuthStatusUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetAuthStatusInfiniteQueryKey = () => {
    return [
    'infinite', `/auth/status`
    ] as const;
    }

export const getGetAuthStatusQueryKey = () => {
    return [
    `/auth/status`
    ] as const;
    }

    
export const getGetAuthStatusInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAuthStatus>>>, TError = unknown>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAuthStatus>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAuthStatusInfiniteQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAuthStatus>>> = ({ signal }) => getAuthStatus({ signal });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAuthStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAuthStatusInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAuthStatus>>>
export type GetAuthStatusInfiniteQueryError = unknown


export function useGetAuthStatusInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAuthStatus>>>, TError = unknown>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAuthStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAuthStatus>>,
          TError,
          Awaited<ReturnType<typeof getAuthStatus>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAuthStatusInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAuthStatus>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAuthStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAuthStatus>>,
          TError,
          Awaited<ReturnType<typeof getAuthStatus>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAuthStatusInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAuthStatus>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAuthStatus>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetAuthStatusInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAuthStatus>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAuthStatus>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAuthStatusInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




export const getGetAuthStatusQueryOptions = <TData = Awaited<ReturnType<typeof getAuthStatus>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthStatus>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAuthStatusQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAuthStatus>>> = ({ signal }) => getAuthStatus({ signal });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAuthStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAuthStatusQueryResult = NonNullable<Awaited<ReturnType<typeof getAuthStatus>>>
export type GetAuthStatusQueryError = unknown


export function useGetAuthStatus<TData = Awaited<ReturnType<typeof getAuthStatus>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAuthStatus>>,
          TError,
          Awaited<ReturnType<typeof getAuthStatus>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAuthStatus<TData = Awaited<ReturnType<typeof getAuthStatus>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAuthStatus>>,
          TError,
          Awaited<ReturnType<typeof getAuthStatus>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAuthStatus<TData = Awaited<ReturnType<typeof getAuthStatus>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthStatus>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetAuthStatus<TData = Awaited<ReturnType<typeof getAuthStatus>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthStatus>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAuthStatusQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




export type getAuthLogoutResponse200 = {
  data: void
  status: 200
}
    
export type getAuthLogoutResponseSuccess = (getAuthLogoutResponse200) & {
  headers: Headers;
};
;

export type getAuthLogoutResponse = (getAuthLogoutResponseSuccess)

export const getGetAuthLogoutUrl = () => {


  

  return `/auth/logout`
}

export const getAuthLogout = async ( options?: RequestInit): Promise<getAuthLogoutResponse> => {
  
  return customInstance<getAuthLogoutResponse>(getGetAuthLogoutUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetAuthLogoutInfiniteQueryKey = () => {
    return [
    'infinite', `/auth/logout`
    ] as const;
    }

export const getGetAuthLogoutQueryKey = () => {
    return [
    `/auth/logout`
    ] as const;
    }

    
export const getGetAuthLogoutInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAuthLogout>>>, TError = unknown>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAuthLogout>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAuthLogoutInfiniteQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAuthLogout>>> = ({ signal }) => getAuthLogout({ signal });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAuthLogout>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAuthLogoutInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAuthLogout>>>
export type GetAuthLogoutInfiniteQueryError = unknown


export function useGetAuthLogoutInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAuthLogout>>>, TError = unknown>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAuthLogout>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAuthLogout>>,
          TError,
          Awaited<ReturnType<typeof getAuthLogout>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAuthLogoutInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAuthLogout>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAuthLogout>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAuthLogout>>,
          TError,
          Awaited<ReturnType<typeof getAuthLogout>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAuthLogoutInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAuthLogout>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAuthLogout>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetAuthLogoutInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAuthLogout>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAuthLogout>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAuthLogoutInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




export const getGetAuthLogoutQueryOptions = <TData = Awaited<ReturnType<typeof getAuthLogout>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthLogout>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAuthLogoutQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAuthLogout>>> = ({ signal }) => getAuthLogout({ signal });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAuthLogout>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAuthLogoutQueryResult = NonNullable<Awaited<ReturnType<typeof getAuthLogout>>>
export type GetAuthLogoutQueryError = unknown


export function useGetAuthLogout<TData = Awaited<ReturnType<typeof getAuthLogout>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthLogout>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAuthLogout>>,
          TError,
          Awaited<ReturnType<typeof getAuthLogout>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAuthLogout<TData = Awaited<ReturnType<typeof getAuthLogout>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthLogout>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAuthLogout>>,
          TError,
          Awaited<ReturnType<typeof getAuthLogout>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAuthLogout<TData = Awaited<ReturnType<typeof getAuthLogout>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthLogout>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetAuthLogout<TData = Awaited<ReturnType<typeof getAuthLogout>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthLogout>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAuthLogoutQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




export type getAuthGoogleResponse200 = {
  data: void
  status: 200
}
    
export type getAuthGoogleResponseSuccess = (getAuthGoogleResponse200) & {
  headers: Headers;
};
;

export type getAuthGoogleResponse = (getAuthGoogleResponseSuccess)

export const getGetAuthGoogleUrl = () => {


  

  return `/auth/google`
}

export const getAuthGoogle = async ( options?: RequestInit): Promise<getAuthGoogleResponse> => {
  
  return customInstance<getAuthGoogleResponse>(getGetAuthGoogleUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetAuthGoogleInfiniteQueryKey = () => {
    return [
    'infinite', `/auth/google`
    ] as const;
    }

export const getGetAuthGoogleQueryKey = () => {
    return [
    `/auth/google`
    ] as const;
    }

    
export const getGetAuthGoogleInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAuthGoogle>>>, TError = unknown>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAuthGoogle>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAuthGoogleInfiniteQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAuthGoogle>>> = ({ signal }) => getAuthGoogle({ signal });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAuthGoogle>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAuthGoogleInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAuthGoogle>>>
export type GetAuthGoogleInfiniteQueryError = unknown


export function useGetAuthGoogleInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAuthGoogle>>>, TError = unknown>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAuthGoogle>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAuthGoogle>>,
          TError,
          Awaited<ReturnType<typeof getAuthGoogle>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAuthGoogleInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAuthGoogle>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAuthGoogle>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAuthGoogle>>,
          TError,
          Awaited<ReturnType<typeof getAuthGoogle>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAuthGoogleInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAuthGoogle>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAuthGoogle>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetAuthGoogleInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAuthGoogle>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAuthGoogle>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAuthGoogleInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




export const getGetAuthGoogleQueryOptions = <TData = Awaited<ReturnType<typeof getAuthGoogle>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthGoogle>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAuthGoogleQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAuthGoogle>>> = ({ signal }) => getAuthGoogle({ signal });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAuthGoogle>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAuthGoogleQueryResult = NonNullable<Awaited<ReturnType<typeof getAuthGoogle>>>
export type GetAuthGoogleQueryError = unknown


export function useGetAuthGoogle<TData = Awaited<ReturnType<typeof getAuthGoogle>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthGoogle>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAuthGoogle>>,
          TError,
          Awaited<ReturnType<typeof getAuthGoogle>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAuthGoogle<TData = Awaited<ReturnType<typeof getAuthGoogle>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthGoogle>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAuthGoogle>>,
          TError,
          Awaited<ReturnType<typeof getAuthGoogle>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAuthGoogle<TData = Awaited<ReturnType<typeof getAuthGoogle>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthGoogle>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetAuthGoogle<TData = Awaited<ReturnType<typeof getAuthGoogle>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthGoogle>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAuthGoogleQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




export type getOauthGoogleCallbackResponse200 = {
  data: void
  status: 200
}
    
export type getOauthGoogleCallbackResponseSuccess = (getOauthGoogleCallbackResponse200) & {
  headers: Headers;
};
;

export type getOauthGoogleCallbackResponse = (getOauthGoogleCallbackResponseSuccess)

export const getGetOauthGoogleCallbackUrl = () => {


  

  return `/oauth/google/callback`
}

export const getOauthGoogleCallback = async ( options?: RequestInit): Promise<getOauthGoogleCallbackResponse> => {
  
  return customInstance<getOauthGoogleCallbackResponse>(getGetOauthGoogleCallbackUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetOauthGoogleCallbackInfiniteQueryKey = () => {
    return [
    'infinite', `/oauth/google/callback`
    ] as const;
    }

export const getGetOauthGoogleCallbackQueryKey = () => {
    return [
    `/oauth/google/callback`
    ] as const;
    }

    
export const getGetOauthGoogleCallbackInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getOauthGoogleCallback>>>, TError = unknown>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOauthGoogleCallback>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOauthGoogleCallbackInfiniteQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOauthGoogleCallback>>> = ({ signal }) => getOauthGoogleCallback({ signal });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOauthGoogleCallback>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOauthGoogleCallbackInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getOauthGoogleCallback>>>
export type GetOauthGoogleCallbackInfiniteQueryError = unknown


export function useGetOauthGoogleCallbackInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOauthGoogleCallback>>>, TError = unknown>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOauthGoogleCallback>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOauthGoogleCallback>>,
          TError,
          Awaited<ReturnType<typeof getOauthGoogleCallback>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOauthGoogleCallbackInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOauthGoogleCallback>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOauthGoogleCallback>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOauthGoogleCallback>>,
          TError,
          Awaited<ReturnType<typeof getOauthGoogleCallback>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOauthGoogleCallbackInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOauthGoogleCallback>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOauthGoogleCallback>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetOauthGoogleCallbackInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOauthGoogleCallback>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOauthGoogleCallback>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetOauthGoogleCallbackInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




export const getGetOauthGoogleCallbackQueryOptions = <TData = Awaited<ReturnType<typeof getOauthGoogleCallback>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOauthGoogleCallback>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOauthGoogleCallbackQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOauthGoogleCallback>>> = ({ signal }) => getOauthGoogleCallback({ signal });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOauthGoogleCallback>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOauthGoogleCallbackQueryResult = NonNullable<Awaited<ReturnType<typeof getOauthGoogleCallback>>>
export type GetOauthGoogleCallbackQueryError = unknown


export function useGetOauthGoogleCallback<TData = Awaited<ReturnType<typeof getOauthGoogleCallback>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOauthGoogleCallback>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOauthGoogleCallback>>,
          TError,
          Awaited<ReturnType<typeof getOauthGoogleCallback>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOauthGoogleCallback<TData = Awaited<ReturnType<typeof getOauthGoogleCallback>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOauthGoogleCallback>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOauthGoogleCallback>>,
          TError,
          Awaited<ReturnType<typeof getOauthGoogleCallback>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOauthGoogleCallback<TData = Awaited<ReturnType<typeof getOauthGoogleCallback>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOauthGoogleCallback>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetOauthGoogleCallback<TData = Awaited<ReturnType<typeof getOauthGoogleCallback>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOauthGoogleCallback>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetOauthGoogleCallbackQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




export type getXAccountResponse200 = {
  data: void
  status: 200
}
    
export type getXAccountResponseSuccess = (getXAccountResponse200) & {
  headers: Headers;
};
;

export type getXAccountResponse = (getXAccountResponseSuccess)

export const getGetXAccountUrl = () => {


  

  return `/x-account/`
}

export const getXAccount = async ( options?: RequestInit): Promise<getXAccountResponse> => {
  
  return customInstance<getXAccountResponse>(getGetXAccountUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetXAccountInfiniteQueryKey = () => {
    return [
    'infinite', `/x-account/`
    ] as const;
    }

export const getGetXAccountQueryKey = () => {
    return [
    `/x-account/`
    ] as const;
    }

    
export const getGetXAccountInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getXAccount>>>, TError = unknown>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getXAccount>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetXAccountInfiniteQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getXAccount>>> = ({ signal }) => getXAccount({ signal });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getXAccount>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetXAccountInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getXAccount>>>
export type GetXAccountInfiniteQueryError = unknown


export function useGetXAccountInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getXAccount>>>, TError = unknown>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getXAccount>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getXAccount>>,
          TError,
          Awaited<ReturnType<typeof getXAccount>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetXAccountInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getXAccount>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getXAccount>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getXAccount>>,
          TError,
          Awaited<ReturnType<typeof getXAccount>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetXAccountInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getXAccount>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getXAccount>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetXAccountInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getXAccount>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getXAccount>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetXAccountInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




export const getGetXAccountQueryOptions = <TData = Awaited<ReturnType<typeof getXAccount>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getXAccount>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetXAccountQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getXAccount>>> = ({ signal }) => getXAccount({ signal });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getXAccount>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetXAccountQueryResult = NonNullable<Awaited<ReturnType<typeof getXAccount>>>
export type GetXAccountQueryError = unknown


export function useGetXAccount<TData = Awaited<ReturnType<typeof getXAccount>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getXAccount>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getXAccount>>,
          TError,
          Awaited<ReturnType<typeof getXAccount>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetXAccount<TData = Awaited<ReturnType<typeof getXAccount>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getXAccount>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getXAccount>>,
          TError,
          Awaited<ReturnType<typeof getXAccount>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetXAccount<TData = Awaited<ReturnType<typeof getXAccount>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getXAccount>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetXAccount<TData = Awaited<ReturnType<typeof getXAccount>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getXAccount>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetXAccountQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




export type postXAccountResponse200 = {
  data: void
  status: 200
}
    
export type postXAccountResponseSuccess = (postXAccountResponse200) & {
  headers: Headers;
};
;

export type postXAccountResponse = (postXAccountResponseSuccess)

export const getPostXAccountUrl = () => {


  

  return `/x-account/`
}

export const postXAccount = async (postXAccountBody: PostXAccountBody, options?: RequestInit): Promise<postXAccountResponse> => {
  
  return customInstance<postXAccountResponse>(getPostXAccountUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      postXAccountBody,)
  }
);}




export const getPostXAccountMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postXAccount>>, TError,{data: PostXAccountBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof postXAccount>>, TError,{data: PostXAccountBody}, TContext> => {

const mutationKey = ['postXAccount'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postXAccount>>, {data: PostXAccountBody}> = (props) => {
          const {data} = props ?? {};

          return  postXAccount(data,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PostXAccountMutationResult = NonNullable<Awaited<ReturnType<typeof postXAccount>>>
    export type PostXAccountMutationBody = PostXAccountBody
    export type PostXAccountMutationError = unknown

    export const usePostXAccount = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postXAccount>>, TError,{data: PostXAccountBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postXAccount>>,
        TError,
        {data: PostXAccountBody},
        TContext
      > => {
      return useMutation(getPostXAccountMutationOptions(options), queryClient);
    }
    export type deleteXAccountResponse200 = {
  data: void
  status: 200
}
    
export type deleteXAccountResponseSuccess = (deleteXAccountResponse200) & {
  headers: Headers;
};
;

export type deleteXAccountResponse = (deleteXAccountResponseSuccess)

export const getDeleteXAccountUrl = () => {


  

  return `/x-account/`
}

export const deleteXAccount = async ( options?: RequestInit): Promise<deleteXAccountResponse> => {
  
  return customInstance<deleteXAccountResponse>(getDeleteXAccountUrl(),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getDeleteXAccountMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteXAccount>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteXAccount>>, TError,void, TContext> => {

const mutationKey = ['deleteXAccount'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteXAccount>>, void> = () => {
          

          return  deleteXAccount()
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteXAccountMutationResult = NonNullable<Awaited<ReturnType<typeof deleteXAccount>>>
    
    export type DeleteXAccountMutationError = unknown

    export const useDeleteXAccount = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteXAccount>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteXAccount>>,
        TError,
        void,
        TContext
      > => {
      return useMutation(getDeleteXAccountMutationOptions(options), queryClient);
    }
    export type postEmailCreateResponse200 = {
  data: void
  status: 200
}
    
export type postEmailCreateResponseSuccess = (postEmailCreateResponse200) & {
  headers: Headers;
};
;

export type postEmailCreateResponse = (postEmailCreateResponseSuccess)

export const getPostEmailCreateUrl = () => {


  

  return `/email/create`
}

export const postEmailCreate = async (postEmailCreateBody: PostEmailCreateBody, options?: RequestInit): Promise<postEmailCreateResponse> => {
  
  return customInstance<postEmailCreateResponse>(getPostEmailCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      postEmailCreateBody,)
  }
);}




export const getPostEmailCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postEmailCreate>>, TError,{data: PostEmailCreateBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof postEmailCreate>>, TError,{data: PostEmailCreateBody}, TContext> => {

const mutationKey = ['postEmailCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postEmailCreate>>, {data: PostEmailCreateBody}> = (props) => {
          const {data} = props ?? {};

          return  postEmailCreate(data,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PostEmailCreateMutationResult = NonNullable<Awaited<ReturnType<typeof postEmailCreate>>>
    export type PostEmailCreateMutationBody = PostEmailCreateBody
    export type PostEmailCreateMutationError = unknown

    export const usePostEmailCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postEmailCreate>>, TError,{data: PostEmailCreateBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postEmailCreate>>,
        TError,
        {data: PostEmailCreateBody},
        TContext
      > => {
      return useMutation(getPostEmailCreateMutationOptions(options), queryClient);
    }
    export type postEmailChatResponse200 = {
  data: void
  status: 200
}
    
export type postEmailChatResponseSuccess = (postEmailChatResponse200) & {
  headers: Headers;
};
;

export type postEmailChatResponse = (postEmailChatResponseSuccess)

export const getPostEmailChatUrl = () => {


  

  return `/email/chat`
}

export const postEmailChat = async (postEmailChatBody: PostEmailChatBody, options?: RequestInit): Promise<postEmailChatResponse> => {
  
  return customInstance<postEmailChatResponse>(getPostEmailChatUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      postEmailChatBody,)
  }
);}




export const getPostEmailChatMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postEmailChat>>, TError,{data: PostEmailChatBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof postEmailChat>>, TError,{data: PostEmailChatBody}, TContext> => {

const mutationKey = ['postEmailChat'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postEmailChat>>, {data: PostEmailChatBody}> = (props) => {
          const {data} = props ?? {};

          return  postEmailChat(data,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PostEmailChatMutationResult = NonNullable<Awaited<ReturnType<typeof postEmailChat>>>
    export type PostEmailChatMutationBody = PostEmailChatBody
    export type PostEmailChatMutationError = unknown

    export const usePostEmailChat = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postEmailChat>>, TError,{data: PostEmailChatBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postEmailChat>>,
        TError,
        {data: PostEmailChatBody},
        TContext
      > => {
      return useMutation(getPostEmailChatMutationOptions(options), queryClient);
    }
    export type postXCreateResponse200 = {
  data: void
  status: 200
}
    
export type postXCreateResponseSuccess = (postXCreateResponse200) & {
  headers: Headers;
};
;

export type postXCreateResponse = (postXCreateResponseSuccess)

export const getPostXCreateUrl = () => {


  

  return `/x/create`
}

export const postXCreate = async (postXCreateBody: PostXCreateBody, options?: RequestInit): Promise<postXCreateResponse> => {
  
  return customInstance<postXCreateResponse>(getPostXCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      postXCreateBody,)
  }
);}




export const getPostXCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postXCreate>>, TError,{data: PostXCreateBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof postXCreate>>, TError,{data: PostXCreateBody}, TContext> => {

const mutationKey = ['postXCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postXCreate>>, {data: PostXCreateBody}> = (props) => {
          const {data} = props ?? {};

          return  postXCreate(data,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PostXCreateMutationResult = NonNullable<Awaited<ReturnType<typeof postXCreate>>>
    export type PostXCreateMutationBody = PostXCreateBody
    export type PostXCreateMutationError = unknown

    export const usePostXCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postXCreate>>, TError,{data: PostXCreateBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postXCreate>>,
        TError,
        {data: PostXCreateBody},
        TContext
      > => {
      return useMutation(getPostXCreateMutationOptions(options), queryClient);
    }
    export type postXChatResponse200 = {
  data: void
  status: 200
}
    
export type postXChatResponseSuccess = (postXChatResponse200) & {
  headers: Headers;
};
;

export type postXChatResponse = (postXChatResponseSuccess)

export const getPostXChatUrl = () => {


  

  return `/x/chat`
}

export const postXChat = async (postXChatBody: PostXChatBody, options?: RequestInit): Promise<postXChatResponse> => {
  
  return customInstance<postXChatResponse>(getPostXChatUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      postXChatBody,)
  }
);}




export const getPostXChatMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postXChat>>, TError,{data: PostXChatBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof postXChat>>, TError,{data: PostXChatBody}, TContext> => {

const mutationKey = ['postXChat'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postXChat>>, {data: PostXChatBody}> = (props) => {
          const {data} = props ?? {};

          return  postXChat(data,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PostXChatMutationResult = NonNullable<Awaited<ReturnType<typeof postXChat>>>
    export type PostXChatMutationBody = PostXChatBody
    export type PostXChatMutationError = unknown

    export const usePostXChat = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postXChat>>, TError,{data: PostXChatBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postXChat>>,
        TError,
        {data: PostXChatBody},
        TContext
      > => {
      return useMutation(getPostXChatMutationOptions(options), queryClient);
    }
    